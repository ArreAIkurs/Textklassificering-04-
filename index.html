<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Biorecensions-analys (Sentiment)</title>
  <meta name="description" content="Webbapp som analyserar om en biorecension √§r positiv eller negativ med en TF.js-modell." />

  <style>
    :root {
      --bg: #0b1220; --card: #111a2b; --accent: #3b82f6; --accent-2: #14b8a6;
      --text: #e5e7eb; --muted: #93a1b1; --bad: #ef4444; --good: #22c55e;
      --border: #1f2a44;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    html, body { background:#0b1220; color:var(--text); margin:0; font-family:var(--font); }
    .wrap { max-width: 1080px; margin: 3rem auto; padding: 0 1rem; }
    header h1 { margin:0 0 .4rem; font-size: clamp(1.6rem, 1rem + 2vw, 2.2rem); }
    header p { margin:.2rem 0 0; color:var(--muted); }

    .grid { display:grid; gap:1rem; grid-template-columns: 1fr; }
    @media (min-width: 1000px) { .grid { grid-template-columns: 1.1fr .9fr; } }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
      border:1px solid var(--border); border-radius:16px; padding:1rem;
    }
    label { font-weight:600; display:block; margin-bottom:.5rem; }
    textarea {
      width:100%; min-height:180px; resize:vertical; background:#0e172a; color:var(--text);
      border:1px solid var(--border); border-radius:12px; padding:.9rem 1rem; font-size:1rem;
    }
    .controls { display:flex; gap:.75rem; align-items:center; flex-wrap:wrap; margin-top:.75rem; }
    button {
      appearance:none; border:0; background:linear-gradient(90deg, var(--accent), var(--accent-2));
      color:#fff; padding:.8rem 1.1rem; border-radius:12px; font-weight:700; cursor:pointer;
    }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .status { color:var(--muted); }

    .pill { display:inline-flex; gap:.5rem; align-items:center; padding:.4rem .7rem; border-radius:999px; font-weight:800; }
    .pill.pos { background:linear-gradient(90deg,#16a34a,#22c55e); }
    .pill.neg { background:linear-gradient(90deg,#ef4444,#f87171); }

    .out { background:#0d1526; border:1px solid var(--border); border-radius:12px; padding:1rem; }
    .bar { height:12px; border-radius:999px; background:#0b1220; border:1px solid var(--border); overflow:hidden; }
    .bar>span { display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent-2)); transition:width .2s ease; }

    /* Debug-panel */
    .debug {
      background:#0a1324; border:1px solid var(--border); border-radius:12px; padding:.75rem; height:260px; overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:.9rem; white-space:pre-wrap;
    }
    .debug-actions { display:flex; gap:.5rem; margin:.5rem 0 .2rem; }
    .badge { display:inline-block; padding:.1rem .4rem; border-radius:6px; background:#0e172a; border:1px solid var(--border); color:#cbd5e1; }
    footer { margin-top:1rem; color:var(--muted); font-size:.92rem; }
    code.kbd { background:#0e172a; border:1px solid var(--border); padding:.05rem .35rem; border-radius:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Analys av biorecension ‚Äì Positiv eller negativ?</h1>
      <p>Skriv en recension och klicka <strong>Analysera</strong>. Modellen k√∂rs i webbl√§saren (TensorFlow.js).</p>
    </header>

    <div class="grid">
      <!-- V√§nster: inmatning -->
      <section class="card">
        <label for="inputText">Din recension</label>
        <textarea id="inputText" placeholder="Exempel: Filmen var fantastisk! Jag vill se den igen."></textarea>
        <div class="controls">
          <button id="analyzeBtn" disabled>Analysera</button>
          <button id="clearBtn">Rensa</button>
          <span class="status" id="status">Laddar‚Ä¶</span>
        </div>
      </section>

      <!-- H√∂ger: resultat + debug -->
      <aside class="card">
        <h3 style="margin:.2rem 0 .6rem;">Resultat</h3>
        <div class="out">
          <div id="label" class="pill" style="display:none;"></div>
          <div style="margin:.6rem 0 .25rem;">Sannolikhet (positiv)</div>
          <div class="bar"><span id="probBar"></span></div>
          <div style="margin-top:.4rem;"><span id="probText">‚Äì</span></div>
          <div style="margin-top:.4rem; color:#93a1b1; font-size:.9rem;">Tr√∂skel: <code class="kbd" id="thresholdText">0.50</code></div>
        </div>

        <h3 style="margin:1rem 0 .5rem;">Debug</h3>
        <div class="debug-actions">
          <span class="badge" id="envBadge">‚Äì</span>
          <button id="copyLogBtn">Kopiera logg</button>
          <button id="clearLogBtn">Rensa logg</button>
        </div>
        <div id="debug" class="debug" aria-live="polite"></div>
      </aside>
    </div>

    <footer>
      <p><strong>GitHub Pages:</strong> Eftersom alla filer ligger i samma mapp r√§cker det att aktivera Pages (Settings ‚Üí Pages) f√∂r vald branch och mapp, s√• betj√§nas allt korrekt.</p>
    </footer>
  </div>

  <!-- ‚úÖ R√§tt TF.js-laddning -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>

  <script>
    // === Konfiguration ===
    // Alla filer ligger i samma mapp som index.html ‚Üí l√§mna BASE_PATH tomt:
    const BASE_PATH = "";               // √§ndra till "models/" om du senare flyttar filerna
    const MODEL_URL = BASE_PATH + "model.json";
    const METADATA_URL = BASE_PATH + "metadata.json";
    const THRESHOLD = 0.5;

    // === UI refs ===
    const $status = document.getElementById("status");
    const $btn = document.getElementById("analyzeBtn");
    const $clear = document.getElementById("clearBtn");
    const $text = document.getElementById("inputText");
    const $label = document.getElementById("label");
    const $probBar = document.getElementById("probBar");
    const $probText = document.getElementById("probText");
    const $thresholdText = document.getElementById("thresholdText");
    const $debug = document.getElementById("debug");
    const $envBadge = document.getElementById("envBadge");
    const $copyLogBtn = document.getElementById("copyLogBtn");
    const $clearLogBtn = document.getElementById("clearLogBtn");
    if ($thresholdText) $thresholdText.textContent = THRESHOLD.toFixed(2);

    // === Debug logger ===
    let debugBuffer = [];
    function ts() {
      const d = new Date();
      return d.toISOString().split("T")[1].replace("Z","");
    }
    function log(...args) {
      const msg = args.map(a => {
        try { return (typeof a === 'string') ? a : JSON.stringify(a, null, 2); }
        catch { return String(a); }
      }).join(" ");
      const line = `[${ts()}] ${msg}`;
      debugBuffer.push(line);
      if ($debug) {
        $debug.textContent += ($debug.textContent ? "\n" : "") + line;
        $debug.scrollTop = $debug.scrollHeight;
      }
      console.log("[DEBUG]", ...args);
    }
    $copyLogBtn.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(debugBuffer.join("\n"));
        log("üìã Kopierade loggen till urklipp.");
      } catch(e) { log("‚ö†Ô∏è Kunde inte kopiera logg:", e?.message || e.toString()); }
    });
    $clearLogBtn.addEventListener("click", () => {
      debugBuffer = [];
      $debug.textContent = "";
      log("üßπ Rensade debuglogg.");
    });
    function setStatus(msg) { if ($status) $status.textContent = msg; log("STATUS:", msg); }

    // === Modellmetadata ===
    let model = null, metadata = null;
    let isGraphModel = false;
    let wordIndex = {};
    let maxLen = 100;
    let lowercase = true;
    let oovToken = "<OOV>";
    let vocabSize = null;

    // F√∂r GraphModel, om du beh√∂ver namnen ‚Äì fyll i efter f√∂rsta loggen:
    const GRAPH_INPUT_NAME = null;   // t.ex. "serving_default_input_1:0"
    const GRAPH_OUTPUT_NAME = null;  // t.ex. "StatefulPartitionedCall:0"

    function simpleNormalize(s) {
      let t = lowercase ? s.toLowerCase() : s;
      t = t.normalize('NFKC').replace(/[^a-z√•√§√∂A-Z√Ö√Ñ√ñ0-9]+/g, ' ').trim();
      return t;
    }
    function tokenize(text) {
      const norm = simpleNormalize(text);
      if (!norm) return [];
      return norm.split(/\s+/);
    }
    function vectorize(text) {
      const tokens = tokenize(text);
      const seq = [];
      const oovIndex = wordIndex[oovToken] ?? wordIndex["<oov>"] ?? wordIndex["<unk>"] ?? 1;
      for (const tok of tokens) {
        let idx = wordIndex[tok];
        if (idx == null) idx = (oovIndex ?? 1);
        if (vocabSize && idx >= vocabSize) idx = (oovIndex ?? 1);
        seq.push(idx);
      }
      const padded = new Array(maxLen).fill(0);
      const start = Math.max(0, maxLen - seq.length);
      for (let i = 0; i < Math.min(seq.length, maxLen); i++) {
        padded[start + i] = seq[seq.length - Math.min(seq.length, maxLen) + i];
      }
      return tf.tensor2d([padded], [1, maxLen]);
    }

    function setOutput(prob) {
      const isPos = prob >= THRESHOLD;
      if ($label) {
        $label.style.display = "inline-flex";
        $label.textContent = isPos ? "Positiv" : "Negativ";
        $label.className = "pill " + (isPos ? "pos" : "neg");
      }
      if ($probBar) $probBar.style.width = Math.max(2, Math.round(prob * 100)) + "%";
      if ($probText) $probText.textContent = (prob * 100).toFixed(1) + " %";
      log("RESULT:", { probability_positive: prob, label: isPos ? "Positiv" : "Negativ" });
    }

    async function safeFetch(url, opts) {
      const res = await fetch(url, { cache: "no-store", ...opts });
      log(opts?.method || "GET", url, "‚Üí", res.status, res.statusText, "| Content-Type:", res.headers.get("content-type"));
      if (!res.ok) throw new Error(`HTTP ${res.status} vid h√§mtning av ${url}`);
      return res;
    }

    async function headCheck(url) {
      try {
        const res = await fetch(url, { method: "HEAD", cache: "no-store" });
        log("HEAD", url, "‚Üí", res.status, res.statusText, "| Content-Type:", res.headers.get("content-type"));
        return res.ok;
      } catch (e) {
        log("HEAD ERROR", url, e?.message || e.toString());
        return false;
      }
    }

    async function detectModelFormat() {
      const res = await safeFetch(MODEL_URL);
      const json = await res.json();

      if (json.format && String(json.format).toLowerCase().includes("graph")) {
        isGraphModel = true;
        log("üîé Uppt√§ckte GRAPH-modell enligt model.json (format:", json.format, ")");
      } else if (json.modelTopology) {
        isGraphModel = false;
        log("üîé Uppt√§ckte LAYERS-modell (modelTopology finns).");
      } else {
        log("‚ö†Ô∏è Kunde inte avg√∂ra modelltyp fr√•n model.json; testar LAYERS f√∂rst, sedan GRAPH vid fel.");
        isGraphModel = false;
      }

      if (json.weightsManifest) log("weightsManifest:", json.weightsManifest);
      return json;
    }

    async function loadAll() {
      try {
        $envBadge.textContent = location.hostname ? ("host: " + location.hostname) : "local file";
        log("üí° Location:", window.location.href);
        log("üí° BASE_PATH:", BASE_PATH);
        log("üí° MODEL_URL:", MODEL_URL);
        log("üí° METADATA_URL:", METADATA_URL);

        // Snabb kontroll: finns filerna?
        await headCheck(MODEL_URL);
        await headCheck(METADATA_URL);

        setStatus("Initierar‚Ä¶");
        log("TFJS version:", tf?.version?.tfjs);

        // 1) Uppt√§ck modelltyp
        await detectModelFormat();

        // 2) Ladda metadata
        setStatus("Laddar metadata‚Ä¶");
        const meta = await safeFetch(METADATA_URL);
        metadata = await meta.json();
        log("metadata:", metadata);

        if (metadata.word_index) wordIndex = metadata.word_index;
        if (metadata.max_len) maxLen = metadata.max_len;
        if (metadata.lowercase !== undefined) lowercase = !!metadata.lowercase;
        if (metadata.oov_token) oovToken = metadata.oov_token;
        if (metadata.vocabulary_size) vocabSize = metadata.vocabulary_size;

        // 3) Ladda modellen med r√§tt loader (med fallback)
        setStatus("Laddar modell‚Ä¶");
        try {
          if (isGraphModel) {
            model = await tf.loadGraphModel(MODEL_URL);
            log("‚úÖ GRAPH-modell laddad.");
          } else {
            model = await tf.loadLayersModel(MODEL_URL);
            log("‚úÖ LAYERS-modell laddad.");
          }
        } catch (e1) {
          log("‚ùå F√∂rsta laddningsf√∂rs√∂ket misslyckades:", e1.message);
          if (isGraphModel) {
            log("Provar LAYERS som fallback‚Ä¶");
            model = await tf.loadLayersModel(MODEL_URL);
            isGraphModel = false;
          } else {
            log("Provar GRAPH som fallback‚Ä¶");
            model = await tf.loadGraphModel(MODEL_URL);
            isGraphModel = true;
          }
          log("‚úÖ Lyckades ladda via fallback. isGraphModel =", isGraphModel);
        }

        // 4) Varmk√∂r / lista I/O-namn
        if (!isGraphModel) {
          tf.tidy(() => model.predict(tf.zeros([1, maxLen])));
        } else {
          // Visa tillg√§ngliga input/output-namn (beh√∂vs vid executeAsync)
          const ins = model?.executor?._inputs?.map(t => t.name);
          const outs = model?.executor?._outputs?.map(t => t.name);
          log("GraphModel inputTensorNames:", ins);
          log("GraphModel outputTensorNames:", outs);
        }

        setStatus("Klar. Skriv en recension och klicka Analysera.");
        $btn.disabled = false;
      } catch (err) {
        console.error(err);
        log("‚ùå LOAD ERROR:", err?.message || err.toString(), "\nSTACK:", err?.stack);
        setStatus("Kunde inte ladda modell/metadata. Se Debug (och Console).");
      }
    }

    async function analyze() {
      const txt = $text.value.trim();
      if (!txt) { setStatus("Skriv n√•got f√∂rst üòä"); return; }
      $btn.disabled = true;
      setStatus("Analyserar‚Ä¶");
      try {
        const input = vectorize(txt);
        log("Vector shape:", input.shape);

        let probPositive = null;

        if (!isGraphModel) {
          // LAYERS
          const out = tf.tidy(() => model.predict(input));
          const data = await out.data();
          out.dispose();
          log("Raw output (Layers):", Array.from(data));
          // Antag 1-utg√•ng (sigmoid); om du tr√§nat [neg, pos], ta data[1].
          probPositive = data.length === 1 ? data[0] : (data[1] ?? data[0]);
        } else {
          // GRAPH
          const inName = GRAPH_INPUT_NAME || (model?.executor?._inputs?.[0]?.name);
          const outName = GRAPH_OUTPUT_NAME || (model?.executor?._outputs?.[0]?.name);
          log("Using input:", inName, "output:", outName);
          if (!inName || !outName) {
            throw new Error("Kan inte k√∂ra GraphModel utan k√§nda input/output-namn. Se debuglistan ovan och s√§tt GRAPH_INPUT_NAME/GRAPH_OUTPUT_NAME i koden.");
          }
          const feeds = {};
          feeds[inName] = input;
          const out = await model.executeAsync(feeds, outName);
          const data = Array.isArray(out) ? await out[0].data() : await out.data();
          if (Array.isArray(out)) out[0].dispose(); else out.dispose();
          log("Raw output (Graph):", Array.from(data));
          probPositive = data.length === 1 ? data[0] : (data[1] ?? data[0]);
        }

        setOutput(probPositive);
        setStatus("Klart.");
      } catch (err) {
        console.error(err);
        log("‚ùå INFERENCE ERROR:", err?.message || err.toString(), "\nSTACK:", err?.stack);
        setStatus("Fel vid inferens. Se Debug & Console.");
      } finally {
        $btn.disabled = false;
      }
    }

    // Event handlers
    document.getElementById("analyzeBtn").addEventListener("click", analyze);
    document.getElementById("clearBtn").addEventListener("click", () => {
      $text.value = "";
      $label.style.display = "none";
      $probBar.style.width = "0%";
      $probText.textContent = "‚Äì";
      setStatus("Rensat. Skriv en ny recension.");
      $text.focus();
      log("UI cleared.");
    });

    // Start
    loadAll();
  </script>
</body>
</html>
